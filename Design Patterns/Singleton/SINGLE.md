он может помогать при тежелых операциях,если мы создаем пулл подключений к базе данных например, или при парсинге где нужно разворачивать целый набор веб драйверов,которые будут все парсить, то есть мы поднимаем много всего, того что занимает много времени,,ресурсов и соответственно мы не хотим чтобы в каких-то частях системы,по ошибке или по незнанию
ктото еще мог создать отдельные вебдрайвера или отдельно все это переподнимал. и нам нужно чтобы наша система сделала тяжелую операцию всего один раз.
так эе этот паттерн нужен для одной точки входа в нашу систему, для нашего пула. и сдесь  реалируеться  singleton, чтобы из любой части системы мы могли по простому достать все5 данные которые нам нужны,которые будут в одном экземпляре,потому что это singleton,потому что это одиночка. 
если мы его сравним с singleton, monostate он проще в реализации чем singleton. то есть нам не нужны сложные конструкции __new__, метаклассы и декораторы,нам достаточно общего _shared_satate и перенаправления__dict__. и неважно один обьект или много-главное чтобы состояние было одно,одна точка входа,то есть одно состояние через которое идет управление всей логикой.
```
class Monostate:
    _shared_state = {}  # одно общее состояние

    def __init__(self):
        self.__dict__ = self._shared_state  
        в#се объекты делят атрибуты


a = Monostate()#создаем 2 разных обьекта,обьект a и его __dict__ будет ссылаться на _shared_state(в начале он пустой)
b = Monostate()

a.value = 100  \здесь уже в _shared_state добавляеться {"value":100}
print(b.value) \обьект b тоже получает __dict__=_shared_state, где уже добавлен,где уже лежит 100

print(a is b)  \и будет false,потому что разные обьекты, но они делят данные даже будучи разными обьектами
```

Он может быть полезен в тех случаях, когда необходимо централизованно управлять ресурсами, к примеру: подключением к базе данных, настройками конфигурации, логированием.
Singleton будет контролировать  создание объекта, обеспечивая, чтобы повторные вызовы не создавали новые экземпляры, а возвращали уже существующий.
Реализация может включать ленивую инициализацию, чтобы создать объект только при первом обращении, а также потоко-безопасность-если объект должен использоваться в многопоточном окружении.
технически он реализуеться через  приватный конструктор (чтобы new нельзя было вызвать снаружи),
```
 class Singleton:
    _instance = None  #тут живёт наш единственный экземпляр
``` 