он может помогать при тежелых операциях,если мы создаем пулл подключений к базе данных например, или при парсинге где нужно разворачивать целый набор веб драйверов,которые будут все парсить, то есть мы поднимаем много всего, того что занимает много времени,,ресурсов и соответственно мы не хотим чтобы в каких-то частях системы,по ошибке или по незнанию
ктото еще мог создать отдельные вебдрайвера или отдельно все это переподнимал. и нам нужно чтобы наша система сделала тяжелую операцию всего один раз.
так эе этот паттерн нужен для одной точки входа в нашу систему, для нашего пула. и сдесь  реалируеться  singleton, чтобы из любой части системы мы могли
по простому достать все5 данные которые нам нужны,которые будут в одном экземпляре,потому что это singleton,потому что это одиночка. 



Он может быть полезен в тех случаях, когда необходимо централизованно управлять ресурсами, к примеру: подключением к базе данных, настройками конфигурации, логированием.
Singleton будет контролировать  создание объекта, обеспечивая, чтобы повторные вызовы не создавали новые экземпляры, а возвращали уже существующий.
Реализация может включать ленивую инициализацию, чтобы создать объект только при первом обращении, а также потоко-безопасность-если объект должен использоваться в многопоточном окружении.
технически он реализуеться через  приватный конструктор (чтобы new нельзя было вызвать снаружи),
```
 class Singleton:
    _instance = None  #тут живёт наш единственный экземпляр
``` 
для вызова методов типа self, вызвать их можно только если передав ссылку на обьект класса,то есть если у нас есть очередная функция с self,например def work(self):, и нам нужно ее выполнить, то в __new__  прописываеться Singleton.work(Singleton.instance), ссылаемся на instance


статическое поле для хранения экземпляра и статический же метод getInstance(), он либо создаёт объект впервые, либо возвращает уже существующий.Но синхронизация тормозит систему, поэтому умные дяди придумали "ленивую инициализацию через внутренний класс" или вообще сразу инициализировать статическое поле — public static final Singleton INSTANCE = new Singleton();



















TODO: Он часто нарушает принцип единственной ответственности (SRP)--- он отвечает и за свою логику, и за контроль над количеством экземпляров.
TODO:может скрыто нарушать инкапсуляцию, становясь по сути глобальной переменной, что делает его особенно опасным в больших проектах.
TODO: маскирует плохой дизайн, заменяя нормальную передачу зависимостей (Dependency Injection) и усложняя модульное тестирование-особенно если реализация зашита напрямую и не позволяет заменить его на заглушку

TODO:в языках с загрузкой классов- Java, или с особенностями импорта-Python, тут допустимо создание нескольких инстансов одного Singleton-класса-например, при сериализации а также десериализации, клонировании, загрузке в разных модуляхили пространствах имён. 
В Java это решается, например, с помощью enum Singleton, а в Python-жёстким контролем на уровне модуля или метакласса. 
та бля 