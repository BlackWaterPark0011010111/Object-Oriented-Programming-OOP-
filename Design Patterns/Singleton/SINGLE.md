он может помогать при тежелых операциях,если мы создаем пулл подключений к базе данных например, или при парсинге где нужно разворачивать целый набор веб драйверов,которые будут все парсить, то есть мы поднимаем много всего, того что занимает много времени,,ресурсов и соответственно мы не хотим чтобы в каких-то частях системы,по ошибке или по незнанию
ктото еще мог создать отдельные вебдрайвера или отдельно все это переподнимал. и нам нужно чтобы наша система сделала тяжелую операцию всего один раз.
так эе этот паттерн нужен для одной точки входа в нашу систему, для нашего пула. и сдесь  реалируеться  singleton, чтобы из любой части системы мы могли по простому достать все5 данные которые нам нужны,которые будут в одном экземпляре,потому что это singleton,потому что это одиночка. 
если мы его сравним с singleton, monostate он проще в реализации чем singleton. то есть нам не нужны сложные конструкции __new__, метаклассы и декораторы,нам достаточно общего _shared_satate и перенаправления__dict__. и неважно один обьект или много-главное чтобы состояние было одно,одна точка входа,то есть одно состояние через которое идет управление всей логикой.
```
class Monostate:
    _shared_state = {}  # одно общее состояние

    def __init__(self):
        self.__dict__ = self._shared_state  
        в#се объекты делят атрибуты


a = Monostate()#создаем 2 разных обьекта,обьект a и его __dict__ будет ссылаться на _shared_state(в начале он пустой)
b = Monostate()

a.value = 100  \здесь уже в _shared_state добавляеться {"value":100}
print(b.value) \обьект b тоже получает __dict__=_shared_state, где уже добавлен,где уже лежит 100

print(a is b)  \и будет false,потому что разные обьекты, но они делят данные даже будучи разными обьектами
```

Он может быть полезен в тех случаях, когда необходимо централизованно управлять ресурсами, к примеру: подключением к базе данных, настройками конфигурации, логированием.
Singleton будет контролировать  создание объекта, обеспечивая, чтобы повторные вызовы не создавали новые экземпляры, а возвращали уже существующий.
Реализация может включать ленивую инициализацию, чтобы создать объект только при первом обращении, а также потоко-безопасность-если объект должен использоваться в многопоточном окружении.
технически он реализуеться через  приватный конструктор (чтобы new нельзя было вызвать снаружи),
```
 class Singleton:
    _instance = None  #тут живёт наш единственный экземпляр
``` 

для вызова методов типа self, вызвать их можно только если передав ссылку на обьект класса,то есть если у нас есть очередная функция с self,например def work(self):, и нам нужно ее выполнить, то в __new__  прописываеться Singleton.work(Singleton.instance), ссылаемся на instance
Заявление от Alex Martelli-"нам не нужно один и тот же обьект, нам нужно одно и тоже состояние!"
и тут появился паттерн Monostate.если мы введем приватную переменную _shared_state (распределенное состояние), то есть,имеется в виду что эта переменная будет распределена между обьектами,которые мы создаем,то есть оно одно и тоже на всех,они все делят одно и тоже состояние- это будет словарь
```
class Monostate:
    _shared_state = {}

    def __init__(self): #без лишних конструкторов с обычным init
        self.__dict__= self._shared_state # dict - это набор всех обьектов
```
здесь мы сделали общую переменную уровня класса(_shared_state = {}),пустой словарь,но только в начале он будет пустой, и мы говорим что каждый созданный обьект будет ссылаться на _shared_state, на это место,то есть атрибуты будут общими,одними и теми же. то есть в __init__ каждый новый экземпляр,он перенаправляет свой __dict__ (который хранит атрибуты объекта) на _shared_state, и после все обьекты будуь использовать один и тот же словарь для зранения атрибутов.
то есть если мы запустим пример из файла sin.py и применим тоже состояние к другой переменной, то оно его приймет, но все так же будет оставаться разными обьектами. но состояние будет одинаковым.и если мы подставим новые атрибуты то все выполняться не будет,с любыми изменениями. singleton и Monostate- это все один и тот же паттерн, ghjcnj один гарантирует что будет один и тот же обьект, а паттерн monostateгарантирует  что состояние будет одно и то же. односистемная глобальная переменная.
Но каждый модуль в силу особенностей в системе импорта -это тоже синглтон, потому что при вставке в python, он тоже один раз импортируеться,создаеться один обьект с названием модуля и он тоже делит свое некое состояние,одну точку системы. то есть мы с ним при импорте тоже будем работать из любых точек системы, и работа выполняться будет тоже один раз 











статическое поле для хранения экземпляра и статический же метод getInstance(), он либо создаёт объект впервые, либо возвращает уже существующий.Но синхронизация тормозит систему, поэтому умные дяди придумали "ленивую инициализацию через внутренний класс" или вообще сразу инициализировать статическое поле — public static final Singleton INSTANCE = new Singleton();

TODO: Он часто нарушает принцип единственной ответственности (SRP)--- он отвечает и за свою логику, и за контроль над количеством экземпляров.
TODO:может скрыто нарушать инкапсуляцию, становясь по сути глобальной переменной, что делает его особенно опасным в больших проектах.
TODO: маскирует плохой дизайн, заменяя нормальную передачу зависимостей (Dependency Injection) и усложняя модульное тестирование-особенно если реализация зашита напрямую и не позволяет заменить его на заглушку

TODO:в языках с загрузкой классов- Java, или с особенностями импорта-Python, тут допустимо создание нескольких инстансов одного Singleton-класса-например, при сериализации а также десериализации, клонировании, загрузке в разных модуляхили пространствах имён. 

В Java это решается, например, с помощью enum Singleton, а в Python-жёстким контролем на уровне модуля или метакласса. 
та бля 
