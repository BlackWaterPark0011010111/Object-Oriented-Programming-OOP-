когда наследуемые классы не могут существовать друг без друга. то есть это жесткая связь.
Главная мысль про композицию - это не просто ещё одна фича ООП, а вообще способ думать о проектировании. Суть в том, что сложные вещи собираются из простых. 
Композиция - это про гибкость на практике. Хочешь поменять поведение? Просто подставь другой объект, не надо городить иерархии наследования. Это как если бы вместо того чтобы переделывать весь автомобиль, ты мог бы просто заменить руль на штурвал и получить амфибию.Каждый маленький объект можно проверить отдельно, а потом уже собирать из проверенных кирпичиков что-то  еще,более замысловатое и сложное. то есть это как убедился что все инструменты в оркестре звучат хорошо, а уже потом собирать из них симфонию. Иногда наследование всё же нужно, особенно когда есть жёсткие "is-a" отношения (круг - это частный случай фигуры, тут без наследования не обойтись). и хитрость в том, чтобы чувствовать, когда что применять.
Самый ценный инсайт, который приходит с опытом (и который я жду): хороший код на композиции читается как рассказ. Вот, класс Band, вот его MusicMan'ы - всё очевидно. А плохой код с навороченным наследованием читаеться как детектив - постоянно гадаешь, какой же метод откуда прилетел на этот раз.
И ещё момент: композиция отлично ложится на современные практики вроде микросервисов. По сути, это тот же принцип - маленькие независимые компоненты, которые собираются во что-то большее. Только в масштабах целой системы.
я сначала начинала  с простого правила - если  сомневаюсь, использовать наследование или композицию, беру композицию. Ошибусь - будет проще переделать. А вот если начну с наследования и ошибусь, переделка будет болезненной.
Но я с фанатизмом. были случаи, когда пара уровней наследования - самое разумное решение. каждый новый уровень - это +1 к сложности поддержки в будущем. 



import __future__
__future__.division



















"has-a" отношения между обьектами
то есть 