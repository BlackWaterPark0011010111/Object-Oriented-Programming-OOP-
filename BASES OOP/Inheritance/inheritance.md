Это тип отношений между классами. В базовом классе идентифицируются поля, методы, поведение, реализация. Это своего рода "контракт" о доступности всех методов и полей, следующие методы должны быть доступны классам-потомкам, и  можно ли их переопределять.
Наследование следует принципу DRY (Don't Repeat Yourself) - избегаем повторения кода. Класс-потомок должен быть более специализирован, чем базовый класс. И поскольку подклассу доступны все детали, это говорит о том, что наследование нарушает принцип инкапсуляции.
То есть если у нас есть 2 независимых класса Человек и Доктор, которые не имеют никакого отношения друг к другу, нам нужно, чтобы они могли выполнять одинаковое действие (то есть чтобы было схожее поведение, так сказать "гены"), то нам придётся прописать функцию-метод (например, "ходить") в первом классе и дублировать её во втором. То есть две одинаковые функции в разных классах. Это плохо.
Нам нужно подключить наследование класса Доктор от Человека, чтобы все функции-методы, всё поведение, все "гены", всё "одинаковое", что делают эти 2 класса, было в одном, а второй просто наследовался от другого и автоматически перенимал на себя всё, что содержит первый класс. Все гены, все функции, которые должны относиться к обоим, будут лишь в одном, и наследование будет грамматически правильным.
И если этих классов будет не 2, а больше, и если они будут в разных файлах, чтобы это не составило труда перенять все те гены, которые есть, на новый класс. Тут та же самая генетика, что и в реальной жизни, только жопу не нужно рвать все 9 месяцев и истерить, чтобы потом спиногрыз вылупился, а всего лишь дело заканчивается нажатием клавиш на клавиатуре)). Хочешь, чтобы наследуемый класс вёл себя как маньяк? Отлично! Пропиши в родительском классе функции маньяка и вуаля!
Но если нам нужно проверить, какой класс является подклассом другого? Тут вступает в силу функция "issubclass". То есть, например:

```print(issubclass("сначала подкласс", "потом генеральный класс"))
print(issubclass(Doctor, Human))```
Выведет значение True, а если поменять местами - то False, потому что должна быть иерархия! Без неё сейчас никуда, даже здесь. Связь классов иерархичная. А когда мы создаём объект, который принадлежит к какому-то классу, и нам нужно проверить, к какому именно этот объект принадлежит, то в силу вступает "isinstance":
```print(isinstance(doc, Doctor))  # --> True```
Количество уровней для наследования не ограничено, и мы можем продолжать цепочку до посинения.

Собственно, как я это понимаю, когда мы проектируем объекты в ООП, есть два важных правила. Первое — объекты не должны быть сильно завязаны друг на друге. Это как в хорошей команде: каждый занимается своим делом, и если один поменяет подход, остальные не развалятся. Например, если у нас есть класс для работы с базой данных и класс для отправки писем, они не должны знать внутренности друг друга — общаются только через чёткие методы. Так система становится гибче: можно что-то переделать в одном месте, и остальное продолжит работать. Второе правило — внутри самого объекта всё должно быть плотно связано. То есть если, условно, класс «Пользователь», он должен отвечать только за данные и логику пользователя, а не лезть в отправку смс или логирование. Иначе получится каша — открываешь класс, а там половина методов вообще не по теме.

В теории:  взял готовый класс, добавил пару методов — и вот тебе новая функциональность. Но на практике часто выходит боком. Представьте,  есть базовый класс «Документ» с методами «сохранить» и «загрузить». От него наследуются «PDF-документ» и «Word-документ» — пока всё ок. Но потом появляется «Документ_В_Оперативке», который вообще не умеет сохраняться. И вот уже проблема: если оставить методы пустыми, они введут в заблуждение, а если кидать ошибку — код, который работает с обычными документами, начнёт ломаться. Это как раз нарушение принципа Лисков: наследник должен уметь всё то же, что и родитель, без сюрпризов.
И таких подводных камней с наследованием — куча. Чем глубже иерархия (чем больше уровней «родителей-детей»), тем сложнее понять, где и что может сломаться. Особенно весело, когда фреймворки навязывают свои огромные цепочки наследования — попробуй разберись, какой метод откуда приехал и почему он вдруг не работает как ожидалось.
Поэтому часто лучше использовать композицию — когда объекты не наследуются, а просто используют друг друга. Например, вместо того чтобы пихать сохранение прямо в класс документа, можно вынести его в отдельный компонент «Сохранение_В_Файл» и подключать только там, где нужно. Тогда «Документ_В_Оперативке» просто не будет его использовать — и никаких костылей не потребуется.

Конечно, бывают случаи, где наследование действительно оправдано — например, в некоторых паттернах проектирования или когда фреймворк жёстко требует именно такой архитектуры. Но если уверенности нет — лучше десять раз подумать, прежде чем строить длинные цепочки наследования. Мертвецы говорят, что в 90% случаев композиция приводит к более гибкому и понятному коду.

Главное что мне нужно запомнить с помощью топора над моей головой это то ,что  ООП — это не про то, чтобы тупо копировать структуры из реального мира в код, а про то, чтобы делать систему удобной для изменений. Если после вашего «красивого наследования» каждый новый функционал требует танцев с бубном — возможно, мне пора пересмотреть подход.


Ведь, вся эта история с ООП: Вначале кажется, что наследование — гениально! есть готовый класс, добавил пару фич — и вот тебе новая сущность. Но потом приходит осознание, что реальный мир слишком сложен для таких прямолинейных иерархий. Это как пытаться описать все многообразие людей через "человек → работник → офисный работник". А где фрилансеры, где гибридные формы, зарплата и котята?? И вот уже твоя красивая схема трещит по швам.Да,инсайты приходят с годами. Потом принцип подстановки Лисков — это не просто про техническую заменяемость, а про контракты в широком смысле. Когда наследник нарушает неявные ожидания — это как сотрудник, который формально выполняет должностные обязанности, но при этом токсично влияет на всю команду. И самое коварное и кровавое это то,что эти проблемы часто всплывают только в продакшене, когда система уже работает у клиентов.

ИИИИИИИИ.... еще про композицию, композиция хороша не только технически, но и психологически как по мне. Когда проектируем систему из независимых компонентов, наш мозг начинает работать иначе(мой чёт только такой отзыв оставил, вот я его собственно и ...). Вместо "как впихнуть эту фичу в существующую иерархию" ты думаешь "как бы пересобрать эти блоки по-новому". 
Это как перейти от Lego с жесткими инструкциями к свободному творчеству с базовыми кирпичиками.
Самые крутые архитекторы, говорят одну вещь: "Хороший дизайн—это когда добавление новой фичи требует создания новых классов, а не изменения существующих". И это чистая правда. Каждый раз, когда мы лезем в рабочий код, чтобы добавить функциональность — мы закладываем мину замедленного действия.Мне особенно весело наблюдать, за самой собой когда я пытаюсь применить наследование для моделирования мира. Но паттерн "Мост" работает не везде. 
Я вижу фишку в том, что настоящее мастерство приходит, когда ты начинаешь чувствовать эти вещи на уровне интуиции, это и так понятно. Ты смотришь на задачу и сразу видишь: "Ага, тут наследованием будет вонять уже через полгода". И самое смешное — потом оказывается, что ты был прав. Узнала,что опытные разработчики называют это "нюхом на архитектурные проблемы", но на самом деле это просто набитые шишки. Аххх мне бы такое))
И про фреймворки. 
Знаю, что есть правило: чем сложнее фреймворк, тем больше в нем нарушений принципов ООП. Кстати WPF-прекрасный пример. Когда видишь иерархию в 10 уровней наследования—авторы сами заложили себе ловушку. И теперь они вынуждены поддерживать этого монстра, потому что обратная совместимость. Это как строить город на древних развалинах — сверху красиво, а внутри сплошные костыли.

Так что мой ответ-я отношусь к наследованию как к острому перцу. Чуть-чуть—вкусно, но перебор испортит любое блюдо. 
А лучшие системы будут получатся, когда я смогу найти баланс между простотой и гибкостью. 