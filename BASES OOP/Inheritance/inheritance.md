Это тип отношений между классами. В базовом классе идентифицируются поля, методы, поведение, реализация. Это своего рода "контракт" о том, что доступность всех методов и полей, следующие методы должны быть доступны классам-потомкам, и можно ли их переопределять.
Наследование следует принципу DRY (Don't Repeat Yourself) - избегаем повторения кода. Класс-потомок должен быть более специализирован, чем базовый класс. И поскольку подклассу доступны все детали, это говорит о том, что наследование нарушает принцип инкапсуляции.
То есть если у нас есть 2 независимых класса Человек и Доктор, которые не имеют никакого отношения друг к другу, нам нужно, чтобы они могли выполнять одинаковое действие (то есть чтобы было схожее поведение, так сказать "гены"), то нам придётся прописать функцию-метод (например, "ходить") в первом классе и дублировать её во втором. То есть две одинаковые функции в разных классах. Это плохо.
Нам нужно подключить наследование класса Доктор от Человека, чтобы все функции-методы, всё поведение, все "гены", всё "одинаковое", что делают эти 2 класса, было в одном, а второй просто наследовался от другого и автоматически перенимал на себя всё, что содержит первый класс. Все гены, все функции, которые должны относиться к обоим, будут лишь в одном, и наследование будет грамматически правильным.
И если этих классов будет не 2, а больше, и если они будут в разных файлах, чтобы это не составило труда перенять все те гены, которые есть, на новый класс. Тут та же самая генетика, что и в реальной жизни, только жопу не нужно рвать все 9 месяцев и истерить, чтобы потом спиногрыз вылупился, а всего лишь дело заканчивается нажатием клавиш на клавиатуре)). Хочешь, чтобы наследуемый класс вёл себя как маньяк? Отлично! Пропиши в родительском классе функции маньяка и вуаля!
Но если нам нужно проверить, какой класс является подклассом другого? Тут вступает в силу функция "issubclass". То есть, например:

```print(issubclass("сначала подкласс", "потом генеральный класс"))
print(issubclass(Doctor, Human))```
Выведет значение True, а если поменять местами - то False, потому что должна быть иерархия! Без неё сейчас никуда, даже здесь. Связь классов иерархичная.

А когда мы создаём объект, который принадлежит к какому-то классу, и нам нужно проверить, к какому именно этот объект принадлежит, то в силу вступает "isinstance":
```print(isinstance(doc, Doctor))  # --> True```
Количество уровней для наследования не ограничено, и мы можем продолжать цепочку до посинения.










