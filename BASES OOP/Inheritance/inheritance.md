это тип отношений между классами, 
в базовом классе индентифицируються поля, методы, поведение, реализация,. Это такого рода "контракт" о том что доступность всех методов и полей следующие методы должны быть доступны классам-потомкам. и можно ли их переопределять.
и наследование следует принципу DRY(Dont repeat yourdelf) избегаем повторение кода. и класс-потомок должен быть более специализирован чем базовый класс. и поскольку под классу доступны все детали, это будет говорить о том что наследование нарушает  принцип инкапсуляции. то есть если у нас есть 2 независимых класса Человек: и Доктор:, которые не имеют никакого отношения к друг другу, нам нужно чтобы они могли выполнять одинаковое действие, то есть чтобы было схожее поведение, так сказать "гены" то нам прийдеться прописать функцию-метод(ходить) в первом классе и дублировать ее во втором. то есть две одинаковые функции в разных классах. Это плохо. Нам нужно подключить наследование класса Доктор: от Человек:, чтобы все функции-методы, все поведение, все "гены", все "одинаковое" что делают эти 2 класса было в одном и втором юез повторений, просто наследовался от другого и автоматически перенимал на себя все что содержит первый класс, все гены, все функции  которые должны относиться к обоим, будут лишь в одном и наследование будет грамматическм правильным. и если этих классов будет не 2 а более и если они будут в разных файлах , чтобы это не составило труда перенять все те гены которые есть на новый класс. Тут та же самая генетика, что и в реальной жизни, только жопу не нужно рвать все 9 месяцев и истерить что бы потом спиногрыз вылупился, а всего лишь дело заканчивается нажатием клавиш на клавиатуре)). Хочешь чтобы наследуемый класс вел себя как маньяк, отлично! пропиши в радительском классе функции маньяка и вуа-ля!
но если нам нужно проверить какой класс являеться подклассом другого? тут вступает в силу  функция "issubclass". то сть, например: print(issubclass("сначала подкласс" , "потом генеральный класс" ))
```print(issubclass(Doctor, Human)``` и выведет значение True, а если поменять местами то False, потому что должна быть иерархия!. Без нее сейчас никуда, даже здесь. Связь классов иерархичная.
а когда мы создаем обьект который пренадлежит к какому-токлассу и нам нужно проверить к какому именно этот обьект принадлежит, то в силу вступает "isinstance" print(isinstance(doc, Doctor)) --> True
колличество уровней для наследования не ограниченый, и мы можем продолжать цепочку до посинения. 



