Класс - это своего рода капсула, которая содержит свойства и методы для работы с этими свойствами. То есть мы их объединяем. Если посмотреть из контекста процедурного программирования - контекст понятен, но с инкапсуляцией добавляется сокрытие.Все свойства и методы могут быть публичными (public), то есть где бы мы ни писали этот код, мы всегда сможем обратиться к этим методам, и логика программы не будет нарушена. Но есть и скрытая часть - она находится внутри класса, и извне мы повлиять на неё не можем. Для этого существуют модификаторы доступа (public, private).
Всё, что мы помечаем модификатором private, мы можем использовать только внутри класса, и вызвать эти элементы извне невозможно. Это нужно для того, чтобы нельзя было изменить важные для работы класса данные. Например, если у нас есть класс Database, где содержатся данные о подключении к БД: пароли, явки, URL, порты, ID - и если кто-то сможет зайти и заменить эти данные на другие, то всё соединение и данные будут утеряны. Именно поэтому мы делаем эти данные приватными, используя "__var" (private) и "_var" (protected).
_Одиночное подчёркивание - это достаточно слабый сигнал «внутреннего использования» или двойное подчёркивание (__var) вызывает name mangling (искажение имён), но это все равно  не настоящая защита.Одиночное подчёркивание - это как табличка «Не влезай, если не разбираешься». Интерпретатор не блокирует доступ, но все понимают, что это для внутреннего использования.с двойным подчеркиванием следующее- при вызове name mangling, интерпретатор автоматически пепеименовывает __password в _ClassName__password. это может усложнять случайный доступ, но злоумышленник всё ещё может обратиться к атрибуту,если знает искажённое имя, потому что если написать:
 ```
class Parent:
def __init__(self):
self.__secret = "123" тут у нас будет _Parent__secret

obj = Parent()  
print(obj._Parent__secret). ---> Вывод:  "123" - доступ есть!.  
```
 Это такое запутывание имен,




db.py
Также если в дальнейшем нам нужно будет что-то удалить, мы используем значения для этих свойств, присваивая их внутри конструктора def __init__(self):. При этом класс содержит в себе список таблиц для базы данных по умолчанию - это пустой массив. Изменять его мы не можем, но можем получать его содержимое. Поэтому для этого списка создаются соответствующие геттеры. При этом нам нужно добавлять таблицы в массив: как аргумент мы принимаем новую таблицу и добавляем её в массив. Взаимодействие с массивом происходит только через специальные методы - напрямую мы его изменить не можем. Мы создаём объект с помощью этого класса, и если попробуем присвоить таблицам пустой массив или добавить какой-то элемент напрямую - у нас ничего не получится. Но мы можем вызвать специальный метод и передать туда нужный объект. А если у нас появится необходимость удалить какие-то таблицы - мы точно так же можем создать соответствующий метод внутри класса и вызывать его в нужном месте. Всё управление данными происходит строго через предусмотренные классом способы, что гарантирует их безопасность и целостность.
свойство @property- это способ контролировать доступ к данным

__slots__ - это значит запрет на самодеятельность. Он ограничивает набор атрибутов объектаесли прописываем ``` __slots__ = ['name', 'email']  # то разрешены будут только эти атрибуты``` это экономия памяти и запрет на  добавление новых атрибутов динамически (например, user.age = 30 вызовет ошибку).